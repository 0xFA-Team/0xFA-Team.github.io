---
layout: post
title: "HCTF-Douglas-Peuker 笔记"
description: "Coding"
headline: 
modified: 2015-12-08
category: Coding
tags: [Coding]
imagefeature: 
mathjax: 
chart: 
author: Dik1s
comments: true
featured: true
---

HCTF的一道PPC，计算的规则很好懂。

![](http://z-onion.cc/1.png)

把每个运算符都考虑成单独的，分别做先后运算，如下：

    ((15+3)*8)-7
    (15+(3*8))-7
    15+((3*8)-7)
    15+(3*(8-7))
    ((15+3)*(8-7)) //+ - *
    ((15+3)*(8-7)) //- + *
	
最后将这些所有式子求出的值相加得到最终结果。

输入形式如下：

	6[2,5,10,9,3,34]++-
	
	
代码需感谢小学弟和大哥的支持。

代码如下：

	#include <stdio.h>
	#include <string.h>
	#include <algorithm>
	#include <iostream>
	#include <sstream>
	#include <vector>
	#include <queue>
	#include <cmath>
	using namespace std;
	#define INF 0x3fffffff
	#define maxn 1000
	
	typedef long long LL;
	const LL MOD = 1e9+7;

	LL A[maxn], C[maxn][maxn];
	char op[maxn];
	LL dp[maxn][maxn];

	int main(int nnnnn,char* args[])
	{
		int n;char ch;
		A[0] = 1;
		for(int i=1; i<=maxn-10; i++)
			A[i] = (A[i-1] * i)%MOD;
			//A内存放阶乘地址
		C[0][0] = 1;//规定排列组合C00=1
		for(int i=1; i<=maxn-10; i++)
		{
			C[i][0] = 1;
			for(int j=1; j<=i; j++)
				C[i][j] = (C[i-1][j-1] + C[i-1][j])%MOD;
		}//计算出排列组合的数，供下方调用。
		stringstream ss(args[1]);
		ss >> n >> ch;
		//n为数据的个数
		{
			memset(dp, 0, sizeof(dp));
			for(int i=1; i<=n; i++)
				ss >> dp[i][i] >> ch;
				//dp[i][i]此时为其中数据，如4[3,8,11,4]*++   d[1][1]=3  d[2][2]=8  以此类推
			ss >> op+1;
			//op内储存符号地址
			for(int L=2; L <= n; L++)
			{
				for(int i=1; i+L-1 <= n; i++)
				{
					int j = i + L - 1;
					dp[i][j] = 0;
					for(int k=i; k<j; k++)
					{
						LL t;
						if(op[k] == '*'){
						t = (dp[i][k]*dp[k+1][j])%MOD;
						}
						if(op[k] == '+'){
						t = (dp[i][k]*A[j-k-1]+dp[k+1][j]*A[k-i])%MOD;
						}
						if(op[k] == '-'){
						t = (dp[i][k]*A[j-k-1]-dp[k+1][j]*A[k-i])%MOD;
						}
						dp[i][j] = (dp[i][j]+t*C[j-i-1][k-i])%MOD;
					}
				}
			}
			printf("%lld\n", (dp[1][n]+MOD)%MOD );
		}
		return 0;
	}


这段代码很有意思，所以总结学习一下。

原本按照计算规则老老实实的写代码的话需要计算的次数为n（n为数据的个数）的阶乘次。那么当计算数据较多的时候将会需要很多的时间。不能够符合题目的要求。

但是这段代码巧妙的减少了时间复杂度。

下面是总结：

	-------------------
	|        |        |
	-------------------
	| n个符号| m个符号 |    
	0        k        p

如上图所示，我们假设有一个式子，在其中随机选取一个符号，作为K。K的左边有n个符号，k的右边有m个符号。

现在假设:

	n=2
	m=3
那么：
	
	n将有两种情况，这两种情况求出的值我们分别记为a,b。
	m将有六种情况，这六种情况我们分别记为A,B,C,D,E,F.

当k为+或者-时，最后的结果为：
		  
		 |-A  =a1                       |-A =b1
		 |-B  =a2                       |-B =b2
		 |-C  =a3                       |-C =b3
	    a(+-)|-D  =a4                  b(+-)|-D =b4 
		 |-E  =a5                       |-E =b5
		 |-F  =a6                       |-F =b6

最终的结果为：

	sum = a1+a2+a3+a4+a5+a6+b1+b2+b3+b4+b5+b6

从这个式子不难看出

	sum = a*A[3](+-)(A+B+C+D+E+F)+b*A[3](+-)(A+B+C+D+E+F)    


![](http://z-onion.cc/2.png)

这也就意味着，k的左边也就是n这一边最后处理的数据为:

	(a+b)*A[m]   (A[m]为m的阶乘)
	
也就是左边按照规则处理完以后的数据乘以右边数据数量的阶乘，以此类推右边也是这个样子。

那么最后的结果就是：

	dp[n]*A[m](+-)dp[m]*A[n]
	dp[n]为左边n个符号处理以后的结果，dp[m]为右边m个符号处理以后的结果.A为阶乘

当k为*时

	sum = a1*a2*a3*a4*a5*a6*b1*b2*b3*b4*b5*b6
	等同于：
	sum = a*(A+B+C+D+E+F)+b*(A+B+C+D+E+F)
	
也就没有阶乘了。

	
好，思想讲完了，现在来分析代码。

输入啥的就不说了，注释里面已经有了，直接分析。

L表示的是当前循环计算的数据，例如当L=2时,如下：

	|15*8|+11+4 -> 15*|8+11|+4
	
dp[i][j]表示的是从第i个数据计算到第j个数据的结果，如

	dp[1][2]=15*8    dp[2][3]=8+11
	
并将结果储存在内存中。

当L=3时，如下：

	|15*8+11|+4 -> 15*|8+11+4|
	
在计算 **15*8+11** 的时候就用到了dp[1][2]和dp[2][3]最后的结果储存到dp[1][3]中供下次递归时使用。

最后考虑排列组合的问题。

	dp[i][j] = (dp[i][j] + t * C[j-i-1][k-i])%MOD; //C[][]储存的是排列组合的值，t是处理完当前K的值以后的结果
	
那么为什么要乘以C[][]呢。

还是那个例子：

	15*8+11+4   现在计算整个式子的值，当K在第二个+的地方。
	处理完(15*8)+(11+4)以后的值为t


但是仔细考虑，这个时候考虑的是分开的，就是后面的一个符号和前面的一个符号分开考虑，那么当他组合在一起呢。

就需要考虑先算（15*8）还是先算（11+4）。现在我们只考虑符号。

这个式子一共有三个符号* + +，去除第二个加号已经是最低优先级运算符不考虑，所以只有两个符号需要考虑。那么可以想象成排列组合。

例如：

	|A |B |
	-------

现在有A,B两个位置可以填运算符。

K的左边有一个运算符*，K的右边有一个运算符+，那么填进去的方式有C[2][1],其中C为排列组合数。

好，现在假设有五个符号

	 * + - + *
	
把K设置在-号的位置。K的左边和K的右边计算结果已经计算出为t

那么现在又有集中排列组合呢？

去掉中间的-号还有四个符号，即还可以填四个符号，如下：


	|A |B |C |D |
	-------------
	
	*  +  +  *
	1  2  3  4

那么因为左右分开考虑计算，那么x+和+x互不影响，也就是1，2和3，4互不影响。也就是把1放进A把2放进D是一样的，因为他们中间的-号是最低优先级。最后依旧算的是：

	（* +）-（+ *）
	
在四个位置中随便抽取两个位置放置前两个1，2.即排列组合为C[4][2]

代入上述代码中，即一共就**j-i-1**个符号需要排列。k左边的符号有**k-i**个。

最后利用递归依次求出解并放置在dp数组中等待调用，知道L为n是循环结束输出最后一组值就是结果。


以上，欢迎指正教育 :)
	
	
